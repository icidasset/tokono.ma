module Markdown exposing (..)

{-|-}

import Parser exposing (..)
import Parser.Extra exposing (..)


parse string =
    Parser.run (parser [] []) string


parseWithOptions { blockParsers, inlineParsers } string =
    Parser.run (parser blockParsers inlineParsers) string


parser customBlockParsers customInlineParsers =
    blocksParser



-- BLOCKS


type Block
    = BlockQuote (Array Block)
    | Heading
        { level : Int
        }
        (Array Inline)
    | Paragraph (Array Inline)


type RawBlock
    = RawBlockQuote String
    | RawHeading
        { level : Int
        }
        String
    | RawParagraph (Array Char)


blocksParser : Parser (Array Block)
blocksParser =
    map
        (Array.foldl
            (\rawBlock blocks ->
                case rawBlock of
                    RawBlockQuote string ->
                        let
                            innerBlocks =
                                parse string
                                    |> Debug.log ""
                                    |> Result.withDefault []
                        in
                        Array.pushLast (BlockQuote innerBlocks) blocks

                    RawHeading props string ->
                        let
                            inlines =
                                parseInline string
                                    |> Debug.log ""
                                    |> Result.withDefault []
                        in
                        Array.pushLast (Heading props inlines) blocks

                    RawParagraph [] ->
                        blocks

                    RawParagraph chars ->
                        let
                            inlines =
                                chars
                                    |> String.fromArray
                                    |> parseInline
                                    |> Debug.log ""
                                    |> Result.withDefault []
                        in
                        Array.pushLast (Paragraph inlines) blocks
            )
            []
        )
        (loop [] rawBlockParser)


rawBlockParser : Array RawBlock -> Parser (Step (Array RawBlock) (Array RawBlock))
rawBlockParser blocks =
    let
        block =
            map (\b -> Loop (Array.pushLast b blocks))
    in
    oneOf
        [ -- Check if we reached the end
          map (\_ -> Done blocks) (succeed identity |. end)

        , --
          block headingParser
        , block blockQuoteParser

        , -- Tries to parse the raw blocks one char at a time.
          succeed
            (\char ->
                case Array.popLast blocks of
                    Just { last = RawParagraph par, initial } ->
                        case
                            { currentChar = char
                            , previousChar = Array.popLast par
                            }
                        of
                            { currentChar = '\n', previousChar = Just { last = '\n', initial = [] } } ->
                                initial
                                    |> Array.pushLast (RawParagraph [])
                                    |> Loop

                            { currentChar = '\n', previousChar = (Just { last = '\n' }) as previousChar } ->
                                initial
                                    |> Array.pushLast
                                            (RawParagraph
                                                <| Maybe.withDefault []
                                                <| Maybe.map .initial previousChar
                                            )
                                    |> Array.pushLast (RawParagraph [])
                                    |> Loop

                            _ ->
                                initial
                                    |> Array.pushLast (RawParagraph (Array.pushLast char par))
                                    |> Loop

                    _ ->
                        blocks
                            |> Array.pushLast (RawParagraph (Array.singleton char))
                            |> Loop
            )
            |= char
        ]


blockQuoteParser : Parser RawBlock
blockQuoteParser =
    succeed identity
        |. notMoreThanXSpaces 3
        |. specificChar '>'
        |= getChompedString (chompUntilEndOr "\n\n")
        |> andThen
                (\string ->
                    -- Take out a single '>' from each line,
                    -- but only if it's led by no more than 3 spaces.
                    string
                        |> String.split "\n"
                        |> Array.map
                                (\line ->
                                    if String.startsWith "    " line then
                                        line
                                    else if String.startsWith ">" (String.trim line) then
                                        String.trim (String.dropLeft 1 (String.trim line))
                                    else
                                        String.trim line
                                )
                        |> String.join "\n"
                        |> RawBlockQuote
                        |> succeed
                )
        |> backtrackable


headingParser : Parser RawBlock
headingParser =
    succeed identity
        |. notMoreThanXSpaces 3
        |= some (specificChar '#')
        |> map (\{ rest } -> 1 + Array.length rest)
        |> andThen
                (\level ->
                    if level > 6 then
                        problem "Headers only go up to 6"
                    else
                        succeed
                            (RawHeading
                                { level = level
                                }
                            )
                            |. some (specificChar ' ')
                            |= getChompedString (chompUntilEndOr "\n")
                            |. oneOf
                                    [ end
                                    , spaces
                                    ]
                )
        |> backtrackable



-- INLINE


type Inline
    = InlineCode String
    | Image
        { alt : String
        , url : String
        }
    | Link
        { text : String
        , url : String
        }
    | Text String


parseInline : String -> Result (Array DeadEnd) (Array Inline)
parseInline =
    Parser.run inlineParser


inlineParser : Parser (Array Inline)
inlineParser =
    loop [] (inlineParserLoop [])


inlineParserLoop : Array (Parser Inline) -> Array Inline -> Parser (Step (Array Inline) (Array Inline))
inlineParserLoop customInlineParsers inlineElements =
    let
        inline =
            map
                (\el ->
                    inlineElements
                        |> Array.pushLast el
                        |> Loop
                )
    in
    Parser.oneOf
        [ -- Check if we reached the end
          map (\_ -> Done inlineElements) end

        , --
          inline (backtrackable codeParser)
        , inline (backtrackable imageParser)
        , inline (backtrackable linkParser)

        , --
          inline (backtrackable (oneOf customInlineParsers))

        , --
          textLoopParser inlineElements
        ]


codeParser : Parser Inline
codeParser =
    succeed identity
        |. specificChar '`'
        |= getChompedString (chompWhile (\c -> c == '`'))
        |> andThen
                (\opening ->
                    succeed identity
                        |= getChompedString (chompUntilEndOr (opening ++ "`"))
                        |. symbol (opening ++ "`")
                        |> map String.trim
                        |> map InlineCode
                )


imageParser : Parser Inline
imageParser =
    succeed identity
        |. symbol "!["
        |= getChompedString (chompUntil "]")
        |. specificChar ']'
        |> andThen
                (\alt ->
                    -- TODO: Support image titles
                    succeed identity
                        |. specificChar '('
                        |= getChompedString (chompUntil ")")
                        |. specificChar ')'
                        |> map
                                (\url ->
                                    Image
                                        { alt = alt
                                        , url = url
                                        }
                                )
                )


linkParser : Parser Inline
linkParser =
    succeed identity
        |. specificChar '['
        |= getChompedString (chompUntil "]")
        |. specificChar ']'
        |> andThen
                (\text ->
                    -- TODO: Support link titles
                    succeed identity
                        |. specificChar '('
                        |= getChompedString (chompUntil ")")
                        |. specificChar ')'
                        |> map
                                (\url ->
                                    Link
                                        { text = text
                                        , url = url
                                        }
                                )
                )


{-| Parses one character at a time, so that it can try the other inline parsers
after each character. Concatenates `Text` automatically.
-}
textLoopParser : Array Inline -> Parser (Step (Array Inline) (Array Inline))
textLoopParser inlineElements =
    succeed
        (\text ->
            case text of
                "" ->
                    Done inlineElements

                _ ->
                    case Array.popLast inlineElements of
                        Just { last, initial } ->
                            case last of
                                Text previousText ->
                                    Loop (Array.pushLast (Text (previousText ++ text)) initial)

                                _ ->
                                    Loop (Array.pushLast (Text text) inlineElements)

                        Nothing ->
                            Loop
                                [ Text text
                                ]
        )
        |= getChompedString chompOne
