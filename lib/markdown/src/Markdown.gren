module Markdown exposing (..)

{-|-}

import Parser exposing (..)
import Parser.Extra exposing (..)


parse string =
    Parser.run (parser [] []) string


parseWithOptions { blockParsers, inlineParsers } string =
    Parser.run (parser blockParsers inlineParsers) string


parser customBlockParsers customInlineParsers =
    blocksParser



-- BLOCKS


type Block
    = Heading
        { level : Int
        }
        (Array Inline)
    | Paragraph (Array Inline)


type RawBlock
    = RawHeading
        { level : Int
        }
        String
    | RawParagraph (Array Char)


blocksParser =
    map
        (Array.foldl
            (\rawBlock blocks ->
                case rawBlock of
                    RawHeading props string ->
                        let
                            inline =
                                parseInline string
                                    |> Debug.log ""
                                    |> Result.withDefault []
                        in
                        Array.pushLast (Heading props inline) blocks

                    RawParagraph [] ->
                        blocks

                    RawParagraph chars ->
                        let
                            inline =
                                chars
                                    |> String.fromArray
                                    |> parseInline
                                    |> Debug.log ""
                                    |> Result.withDefault []
                        in
                        Array.pushLast (Paragraph inline) blocks
            )
            []
        )
        (loop [] rawBlockParser)


rawBlockParser blocks =
    oneOf
        [ -- Check if we reached the end
          map (\_ -> Done blocks) (succeed identity |. end)

        , -- 
          map (\b -> Loop (Array.pushLast b blocks)) headingParser

        , -- Tries to parse the raw blocks one char at a time.
          succeed
            (\char ->
                case Array.popLast blocks of
                    Just { last = RawParagraph par, initial } ->
                        case
                            { currentChar = char
                            , previousChar = Array.popLast par
                            }
                        of
                            { currentChar = '\n', previousChar = Just { last = '\n', initial = [] } } ->
                                initial
                                    |> Array.pushLast (RawParagraph [])
                                    |> Loop

                            { currentChar = '\n', previousChar = (Just { last = '\n' }) as previousChar } ->
                                initial
                                    |> Array.pushLast
                                            (RawParagraph
                                                <| Maybe.withDefault []
                                                <| Maybe.map .initial previousChar
                                            )
                                    |> Array.pushLast (RawParagraph [])
                                    |> Loop

                            _ ->
                                initial
                                    |> Array.pushLast (RawParagraph (Array.pushLast char par))
                                    |> Loop

                    _ ->
                        blocks
                            |> Array.pushLast (RawParagraph (Array.singleton char))
                            |> Loop
            )
            |= char
        ]


headingParser : Parser RawBlock
headingParser =
    succeed identity
        |. notMoreThanXSpaces 3
        |= some (specificChar '#')
        |> map (\{ rest } -> 1 + Array.length rest)
        |> andThen
                (\level ->
                    if level > 6 then
                        problem "Headers only go up to 6"
                    else
                        succeed
                            (RawHeading
                                { level = level
                                }
                            )
                            |. some (specificChar ' ')
                            |= getChompedString (chompUntilEndOr "\n")
                            |. oneOf
                                    [ end
                                    , spaces
                                    ]
                )
        |> backtrackable



-- INLINE


type Inline
    = InlineCode String
    | Image
        { alt : String
        , url : String
        }
    | Link
        { text : String
        , url : String
        }
    | Text String


parseInline : String -> Result (Array DeadEnd) (Array Inline)
parseInline =
    Parser.run (loop [] (inlineParser []))


inlineParser : Array (Parser Inline) -> Array Inline -> Parser (Step (Array Inline) (Array Inline))
inlineParser customInlineParsers inlineElements =
    let
        inline =
            map
                (\el ->
                    inlineElements
                        |> Array.pushLast el
                        |> Loop
                )
    in
    Parser.oneOf
        [ -- Check if we reached the end
          map (\_ -> Done inlineElements) end

        , -- 
          inline (backtrackable codeParser)
        , inline (backtrackable imageParser)
        , inline (backtrackable linkParser)

        , -- 
          inline (backtrackable (oneOf customInlineParsers))

        , -- 
          textLoopParser inlineElements
        ]


codeParser : Parser Inline
codeParser =
    succeed identity
        |. specificChar '`'
        |= getChompedString (chompWhile (\c -> c == '`'))
        |> andThen
                (\opening ->
                    succeed identity
                        |= getChompedString (chompUntilEndOr (opening ++ "`"))
                        |. symbol (opening ++ "`")
                        |> map String.trim
                        |> map InlineCode
                )


imageParser : Parser Inline
imageParser =
    succeed identity
        |. symbol "!["
        |= getChompedString (chompUntil "]")
        |. specificChar ']'
        |> andThen
                (\alt ->
                    -- TODO: Support image titles
                    succeed identity
                        |. specificChar '('
                        |= getChompedString (chompUntil ")")
                        |. specificChar ')'
                        |> map
                                (\url ->
                                    Image
                                        { alt = alt
                                        , url = url
                                        }
                                )
                )


linkParser : Parser Inline
linkParser =
    succeed identity
        |. specificChar '['
        |= getChompedString (chompUntil "]")
        |. specificChar ']'
        |> andThen
                (\text ->
                    -- TODO: Support link titles
                    succeed identity
                        |. specificChar '('
                        |= getChompedString (chompUntil ")")
                        |. specificChar ')'
                        |> map
                                (\url ->
                                    Link
                                        { text = text
                                        , url = url
                                        }
                                )
                )


{-| Parses one character at a time, so that it can try the other inline parsers
after each character. Concatenates `Text` automatically.
-}
textLoopParser : Array Inline -> Parser (Step (Array Inline) (Array Inline))
textLoopParser inlineElements =
    succeed
        (\text ->
            case text of
                "" ->
                    Done inlineElements

                _ ->
                    case Array.popLast inlineElements of
                        Just { last, initial } ->
                            case last of
                                Text previousText ->
                                    Loop (Array.pushLast (Text (previousText ++ text)) initial)

                                _ ->
                                    Loop (Array.pushLast (Text text) inlineElements)

                        Nothing ->
                            Loop
                                [ Text text
                                ]
        )
        |= getChompedString chompOne
