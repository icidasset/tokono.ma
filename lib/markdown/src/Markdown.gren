module Markdown exposing (..)

{-|-}

import Parser exposing (..)
import Parser.Extra exposing (..)


parse string =
    Parser.run (parser [] []) string


parseWithOptions { blockParsers, inlineParsers } string =
    Parser.run (parser blockParsers inlineParsers) string


parser customBlockParsers customInlineParsers =
    blocksParser



-- BLOCKS


type Block
    = BlockQuote (Array Block)
    | Heading
        { level : Int
        }
        (Array Inline)
    | Paragraph (Array Inline)
    | ThematicBreak


type RawBlock
    = RawBlockQuote String
    | RawHeading
        { level : Int
        }
        String
    | RawParagraph String
    | RawThematicBreak


blocksParser : Parser (Array Block)
blocksParser =
    map
        (Array.foldl
            (\rawBlock blocks ->
                case rawBlock of
                    RawBlockQuote string ->
                        let
                            innerBlocks =
                                parse string
                                    |> Result.withDefault []
                        in
                        Array.pushLast (BlockQuote innerBlocks) blocks

                    RawHeading props string ->
                        let
                            inlines =
                                parseInline string
                                    |> Result.withDefault []
                        in
                        Array.pushLast (Heading props inlines) blocks

                    RawParagraph string ->
                        let
                            inlines =
                                string
                                    |> parseInline
                                    |> Result.withDefault []
                        in
                        Array.pushLast (Paragraph inlines) blocks

                    RawThematicBreak ->
                        Array.pushLast ThematicBreak blocks
            )
            []
        )
        (loop [] rawBlockParser)


rawBlockParser : Array RawBlock -> Parser (Step (Array RawBlock) (Array RawBlock))
rawBlockParser blocks =
    let
        block =
            map (\b -> Loop (Array.pushLast b blocks))
    in
    oneOf
        [ -- Check if we reached the end
          map (\_ -> Done blocks) (succeed identity |. end)

        , -- 
          block (backtrackable headingParser)
        , block (backtrackable blockQuoteParser)
        , block (backtrackable thematicBreakParser)

        , -- If all fails, then it's a paragraph.
          -- Try parsing one line at a time.
          succeed
            (\line ->
                case Array.popLast blocks of
                    Just { last = RawParagraph par, initial } ->
                        initial
                            |> Array.pushLast (RawParagraph (par ++ "\n" ++ line))
                            |> Loop

                    _ ->
                        blocks
                            |> Array.pushLast (RawParagraph line)
                            |> Loop
            )
            |. spaces
            |= getChompedString (chompUntilEndOr "\n")
            |. spaces
        ]


blockQuoteParser : Parser RawBlock
blockQuoteParser =
    succeed identity
        |. notMoreThanXSpaces 3
        |. specificChar '>'
        |= getChompedString (chompUntilEndOr "\n\n")
        |. spaces
        |> andThen
                (\string ->
                    -- Take out a single '>' from each line,
                    -- but only if it's led by no more than 3 spaces.
                    string
                        |> String.split "\n"
                        |> Array.map
                                (\line ->
                                    if String.startsWith "    " line then
                                        line
                                    else if String.startsWith ">" (String.trim line) then
                                        String.trim (String.dropLeft 1 (String.trim line))
                                    else
                                        String.trim line
                                )
                        |> String.join "\n"
                        |> RawBlockQuote
                        |> succeed
                )


headingParser : Parser RawBlock
headingParser =
    succeed identity
        |. notMoreThanXSpaces 3
        |= some (specificChar '#')
        |> map (\{ rest } -> 1 + Array.length rest)
        |> andThen
                (\level ->
                    if level > 6 then
                        problem "Headers only go up to 6"
                    else
                        succeed
                            (RawHeading
                                { level = level
                                }
                            )
                            |. some (specificChar ' ')
                            |= getChompedString (chompUntilEndOr "\n")
                            |. oneOf
                                    [ end
                                    , spaces
                                    ]
                )


thematicBreakParser =
    succeed identity
        |. notMoreThanXSpaces 3
        |= oneOf
                [ specificChar '-'
                , specificChar '_'
                , specificChar '*'
                ]
        |> andThen
                (\openingChar ->
                    let
                        term =
                            String.fromArray (Array.repeat 2 openingChar)
                    in
                    succeed identity
                        |= getChompedString (chompUntilEndOr "\n")
                        |. spaces
                        |> andThen
                                (\text ->
                                    if String.startsWith term text then
                                        succeed RawThematicBreak
                                    else
                                        problem "Not a thematic break"
                                )
                )



-- INLINE


type Inline
    = Emphasis
        { times : Int
        }
        String
    | HardLineBreak
    | InlineCode String
    | Image
        { alt : String
        , url : String
        }
    | Link
        { text : String
        , url : String
        }
    | Text String


parseInline : String -> Result (Array DeadEnd) (Array Inline)
parseInline =
    Parser.run inlineParser


inlineParser : Parser (Array Inline)
inlineParser =
    loop [] (inlineParserLoop [])


inlineParserLoop : Array (Parser Inline) -> Array Inline -> Parser (Step (Array Inline) (Array Inline))
inlineParserLoop customInlineParsers inlineElements =
    let
        inline =
            map
                (\el ->
                    inlineElements
                        |> Array.pushLast el
                        |> Loop
                )

        lastElement =
            Array.last inlineElements
    in
    Parser.oneOf
        [ -- Check if we reached the end
          map (\_ -> Done inlineElements) end

        , -- 
          inline (backtrackable (emphasisWithUnderscoreParser lastElement))
        , inline (backtrackable emphasisWithStarParser)
        , inline (backtrackable hardLineBreakParser)
        , inline (backtrackable imageParser)
        , inline (backtrackable inlineCodeParser)
        , inline (backtrackable linkParser)

        , -- 
          inline (backtrackable (oneOf customInlineParsers))

        , -- 
          textLoopParser inlineElements lastElement
        ]


emphasisWithStarParser : Parser Inline
emphasisWithStarParser =
    succeed identity
        |= some (specificChar '*')
        |> andThen
                (\opening ->
                    let
                        closing =
                            "*" ++ String.fromArray opening.rest

                        times =
                            String.length closing
                    in
                    succeed identity
                        |= getChompedString (chompUntilEndOr closing)
                        |. symbol closing
                        |> andThen
                                (\emphasisedText ->
                                    let
                                        chars =
                                            String.toArray emphasisedText

                                        firstChar =
                                            Maybe.withDefault ' ' (Array.first chars)
                                    in
                                    if isUnicodeSpace firstChar || isPunctuation firstChar then
                                        problem "Illegal character, cannot emphasise"
                                    else
                                        emphasisedText
                                            |> Emphasis
                                                    { times = times
                                                    }
                                            |> succeed
                                )
                )


emphasisWithUnderscoreParser : Maybe Inline -> Parser Inline
emphasisWithUnderscoreParser lastElement =
    let
        isPrecededByASpaceOrNothing =
            case lastElement of
                Just (Text t) ->
                    case Array.last (String.toArray t) of
                        Just char ->
                            isUnicodeSpace char

                        Nothing ->
                            True

                _ ->
                    True
    in
    if isPrecededByASpaceOrNothing then
        succeed identity
            |= some (specificChar '_')
            |> andThen
                    (\opening ->
                        let
                            closing =
                                "_" ++ String.fromArray opening.rest

                            times =
                                String.length closing
                        in
                        succeed identity
                            |= getChompedString (chompUntilEndOr closing)
                            |. symbol closing
                            |> andThen
                                    (\emphasisedText ->
                                        let
                                            chars =
                                                String.toArray emphasisedText

                                            firstChar =
                                                Maybe.withDefault ' ' (Array.first chars)
                                        in
                                        if isUnicodeSpace firstChar || isPunctuation firstChar then
                                            problem "Illegal character, cannot emphasise"
                                        else
                                            emphasisedText
                                                |> Emphasis
                                                        { times = times
                                                        }
                                                |> succeed
                                    )
                    )
    else
        problem "Cannot emphasise if not preceded by a space"


hardLineBreakParser : Parser Inline
hardLineBreakParser =
    succeed identity
        |. specificChar ' '
        |. specificChar ' '
        |. many (specificChar ' ')
        |. specificChar '\n'
        |> map (\_ -> HardLineBreak)


imageParser : Parser Inline
imageParser =
    succeed identity
        |. symbol "!["
        |= getChompedString (chompUntil "]")
        |. specificChar ']'
        |> andThen
                (\alt ->
                    -- TODO: Support image titles
                    succeed identity
                        |. specificChar '('
                        |= getChompedString (chompUntil ")")
                        |. specificChar ')'
                        |> map
                                (\url ->
                                    Image
                                        { alt = alt
                                        , url = url
                                        }
                                )
                )


inlineCodeParser : Parser Inline
inlineCodeParser =
    succeed identity
        |. specificChar '`'
        |= getChompedString (chompWhile (\c -> c == '`'))
        |> andThen
                (\opening ->
                    succeed identity
                        |= getChompedString (chompUntilEndOr (opening ++ "`"))
                        |. symbol (opening ++ "`")
                        |> map String.trim
                        |> map InlineCode
                )


linkParser : Parser Inline
linkParser =
    succeed identity
        |. specificChar '['
        |= getChompedString (chompUntil "]")
        |. specificChar ']'
        |> andThen
                (\text ->
                    -- TODO: Support link titles
                    succeed identity
                        |. specificChar '('
                        |= getChompedString (chompUntil ")")
                        |. specificChar ')'
                        |> map
                                (\url ->
                                    Link
                                        { text = text
                                        , url = url
                                        }
                                )
                )


{-| Parses one character at a time, so that it can try the other inline parsers
after each character. Concatenates `Text` automatically.
-}
textLoopParser : Array Inline -> Maybe Inline -> Parser (Step (Array Inline) (Array Inline))
textLoopParser inlineElements lastElement =
    succeed
        (\text ->
            case text of
                "" ->
                    Done inlineElements

                _ ->
                    case lastElement of
                        Just (Text previousText) ->
                            Loop (Array.pushLast (Text (previousText ++ text)) (Array.dropLast 1 inlineElements))

                        _ ->
                            Loop (Array.pushLast (Text text) inlineElements)
        )
        |= getChompedString chompOne
