module Markdown.Parser.Inlines exposing (..)

{-|-}

import Markdown.Inline exposing ( Inline(..) )
import Parser exposing (..)
import Parser.Extra exposing (..)



-- 🛠️


parse : String -> Result (Array DeadEnd) (Array Inline)
parse =
    Parser.run parser



-- TOP-LEVEL PARSER


parser : Parser (Array Inline)
parser =
    loop [] (parserLoop [])


parserLoop : Array (Parser Inline) -> Array Inline -> Parser (Step (Array Inline) (Array Inline))
parserLoop customInlineParsers inlineElements =
    let
        inline =
            map
                (\el ->
                    inlineElements
                        |> Array.pushLast el
                        |> Loop
                )

        lastElement =
            Array.last inlineElements
    in
    Parser.oneOf
        [ -- Check if we reached the end
          map (\_ -> Done inlineElements) end

        , -- 
          inline (backtrackable (emphasisWithUnderscoreParser lastElement))
        , inline (backtrackable emphasisWithStarParser)
        , inline (backtrackable hardLineBreakParser)
        , inline (backtrackable imageParser)
        , inline (backtrackable linkParser)

        , -- 
          inline (backtrackable (oneOf customInlineParsers))

        , -- 
          backtrackable (inlineCodeParser inlineElements lastElement)

        , -- 
          textLoopParser inlineElements lastElement
        ]



-- INDIVIDUAL PARSERS


emphasisWithStarParser : Parser Inline
emphasisWithStarParser =
    succeed identity
        |= some (specificChar '*')
        |> andThen
                (\opening ->
                    let
                        closing =
                            "*" ++ String.fromArray opening.rest

                        times =
                            String.length closing
                    in
                    succeed identity
                        |= getChompedString (chompUntilEndOr closing)
                        |. symbol closing
                        |> andThen
                                (\emphasisedText ->
                                    let
                                        chars =
                                            String.toArray emphasisedText

                                        firstChar =
                                            Maybe.withDefault ' ' (Array.first chars)
                                    in
                                    if isUnicodeSpace firstChar || isPunctuation firstChar then
                                        problem "Illegal character, cannot emphasise"
                                    else
                                        emphasisedText
                                            |> Emphasis
                                                    { times = times
                                                    }
                                            |> succeed
                                )
                )


emphasisWithUnderscoreParser : Maybe Inline -> Parser Inline
emphasisWithUnderscoreParser lastElement =
    let
        isPrecededByASpaceOrNothing =
            case lastElement of
                Just (Text t) ->
                    case Array.last (String.toArray t) of
                        Just char ->
                            isUnicodeSpace char

                        Nothing ->
                            True

                _ ->
                    True
    in
    if isPrecededByASpaceOrNothing then
        succeed identity
            |= some (specificChar '_')
            |> andThen
                    (\opening ->
                        let
                            closing =
                                "_" ++ String.fromArray opening.rest

                            times =
                                String.length closing
                        in
                        succeed identity
                            |= getChompedString (chompUntilEndOr closing)
                            |. symbol closing
                            |> andThen
                                    (\emphasisedText ->
                                        let
                                            chars =
                                                String.toArray emphasisedText

                                            firstChar =
                                                Maybe.withDefault ' ' (Array.first chars)
                                        in
                                        if isUnicodeSpace firstChar || isPunctuation firstChar then
                                            problem "Illegal character, cannot emphasise"
                                        else
                                            emphasisedText
                                                |> Emphasis
                                                        { times = times
                                                        }
                                                |> succeed
                                    )
                    )
    else
        problem "Cannot emphasise if not preceded by a space"


hardLineBreakParser : Parser Inline
hardLineBreakParser =
    succeed identity
        |. specificChar ' '
        |. specificChar ' '
        |. many (specificChar ' ')
        |. specificChar '\n'
        |> map (\_ -> HardLineBreak)


imageParser : Parser Inline
imageParser =
    succeed identity
        |. symbol "!["
        |= getChompedString (chompUntil "]")
        |. specificChar ']'
        |> andThen
                (\alt ->
                    -- TODO: Support image titles
                    succeed identity
                        |. specificChar '('
                        |= getChompedString (chompUntil ")")
                        |. specificChar ')'
                        |> map
                                (\url ->
                                    Image
                                        { alt = alt
                                        , url = url
                                        }
                                )
                )


inlineCodeParser : Array Inline -> Maybe Inline -> Parser (Step (Array Inline) (Array Inline))
inlineCodeParser inlineElements lastElement =
    succeed identity
        |. specificChar '`'
        |= getChompedString (chompWhile (\c -> c == '`'))
        |> andThen
                (\opening ->
                    let
                        completeOpening =
                            opening ++ "`"
                    in
                    oneOf
                        [ succeed identity
                            |= getChompedString (chompUntilEndOr completeOpening)
                            |. symbol completeOpening
                            |> backtrackable
                            |> map String.trim
                            |> map InlineCode
                            |> andThen
                                    (\code ->
                                        succeed identity
                                            |= oneOf
                                                    [ map (\_ -> True) (lookAhead (specificChar '`'))
                                                    , succeed False
                                                    ]
                                            |> andThen
                                                    (\bool ->
                                                        if bool then
                                                            -- TODO: Continue chomping
                                                            problem "Too much closing \'`\' characters"
                                                        else
                                                            succeed code
                                                    )
                                    )
                            |> map (\el -> Loop (Array.pushLast el inlineElements))

                        , -- 
                          succeed (textLoop inlineElements lastElement completeOpening)
                        ]
                )


linkParser : Parser Inline
linkParser =
    succeed identity
        |. specificChar '['
        |= getChompedString (chompUntil "]")
        |. specificChar ']'
        |> andThen
                (\text ->
                    -- TODO: Support link titles
                    succeed identity
                        |. specificChar '('
                        |= getChompedString (chompUntil ")")
                        |. specificChar ')'
                        |> map
                                (\url ->
                                    Link
                                        { text = text
                                        , url = url
                                        }
                                )
                )


{-| Parses one character at a time, so that it can try the other inline parsers
after each character. Concatenates `Text` automatically.
-}
textLoopParser : Array Inline -> Maybe Inline -> Parser (Step (Array Inline) (Array Inline))
textLoopParser inlineElements lastElement =
    succeed (textLoop inlineElements lastElement) |= getChompedString chompOne



-- ㊙️


textLoop : Array Inline -> Maybe Inline -> String -> Step (Array Inline) (Array Inline)
textLoop inlineElements lastElement text =
    case text of
        "" ->
            Done inlineElements

        _ ->
            case lastElement of
                Just (Text previousText) ->
                    Loop (Array.pushLast (Text (previousText ++ text)) (Array.dropLast 1 inlineElements))

                _ ->
                    Loop (Array.pushLast (Text text) inlineElements)
