module Markdown.Parser.Inlines exposing (..)

{-|-}

import Markdown.Inline exposing ( Inline(..) )
import Parser exposing (..)
import Parser.Extra exposing (..)



-- ðŸ› ï¸


parse : String -> Result (Array DeadEnd) (Array Inline)
parse =
    Parser.run parser



-- TOP-LEVEL PARSER


parser : Parser (Array Inline)
parser =
    loop [] (parserLoop [])


parserLoop : Array (Parser Inline) -> Array Inline -> Parser (Step (Array Inline) (Array Inline))
parserLoop customInlineParsers inlineElements =
    let
        inline =
            map
                (\el ->
                    inlineElements
                        |> Array.pushLast el
                        |> Loop
                )

        lastElement =
            Array.last inlineElements
    in
    Parser.oneOf
        [ -- Check if we reached the end
          map (\_ -> Done inlineElements) end

        , -- 
          backtrackable (inlineCodeParser inlineElements lastElement)

        , -- 
          inline (backtrackable (emphasisWithUnderscoreParser lastElement))
        , inline (backtrackable (emphasisWithStarParser lastElement))
        , inline (backtrackable hardLineBreakParser)
        , inline (backtrackable imageParser)
        , inline (backtrackable linkParser)

        , -- 
          inline (backtrackable (oneOf customInlineParsers))

        , -- 
          textLoopParser inlineElements lastElement
        ]



-- INDIVIDUAL PARSERS


emphasisParser : Char -> Maybe Inline -> Parser Inline
emphasisParser emphasisChar lastElement =
    let
        originalCharBefore =
            case lastElement of
                Just (Text t) ->
                    Array.last (String.toArray t)

                _ ->
                    Nothing

        chompUntilNextClosing opts =
            let
                _ =
                    Debug.log "chomp" opts
            in
            succeed identity
                |= getChompedString (chompUntilEndOr opts.closing)
                |. symbol opts.closing
                |> andThen (check opts)

        isViableOpening charBefore firstChar =
            let
                isPrecededByASpacePunctuationOrNothing =
                    case charBefore of
                        Just char ->
                            isUnicodeSpace char || isPunctuation char

                        _ ->
                            True

                isPrecededByPartialOpening =
                    case charBefore of
                        Just char ->
                            char == emphasisChar

                        Nothing ->
                            False
            in
            if isPrecededByPartialOpening then
                False
            else if Maybe.map isUnicodeSpace firstChar == Just True then
                False
            else if Maybe.map isPunctuation firstChar == Just True then
                isPrecededByASpacePunctuationOrNothing
            else
                True

        check opts additionalEmphasisedText =
            let
                allEmphasisedText =
                    opts.emphasisedText ++ additionalEmphasisedText

                chars =
                    String.toArray allEmphasisedText

                firstChar =
                    if opts.checkOpening then
                        Array.first chars
                    else
                        Maybe.map .first (String.uncons additionalEmphasisedText)

                lastCharPrevious =
                    Array.last (String.toArray (String.dropRight (String.length opts.closing) opts.emphasisedText))

                lastChar =
                    Array.last chars

                chompOpts =
                    { opts
                        | checkOpening = False
                        , emphasisedText = allEmphasisedText ++ opts.closing
                    }
            in
            if opts.checkOpening && not (isViableOpening originalCharBefore firstChar) then
                problem "Illegal character, cannot emphasise"
            else if not opts.checkOpening && isViableOpening lastCharPrevious firstChar then
                oneOf
                    [ chompUntilNextClosing chompOpts
                    , succeed allEmphasisedText
                    ]
            else if Maybe.map isUnicodeSpace lastChar == Just True then
                chompUntilNextClosing chompOpts
            else if Maybe.map isPunctuation lastChar == Just True then
                succeed identity
                    |= oneOf
                            [ map (\_ -> True) (lookAhead (chompIf (\c -> isUnicodeSpace c || isPunctuation c)))
                            , map (\_ -> True) (lookAhead end)
                            , succeed False
                            ]
                    |> andThen
                            (\isViableClosing ->
                                if isViableClosing then
                                    succeed allEmphasisedText
                                else
                                    chompUntilNextClosing chompOpts
                            )
            else if String.contains "`" allEmphasisedText then
                problem "Inline code has precedence"
            else if emphasisChar == '_' then
                -- Disallow intraword
                oneOf
                    [ succeed identity
                        |. lookAhead
                                (oneOf
                                    [ chompIf (\c -> isUnicodeSpace c || isPunctuation c)
                                    , end
                                    ]
                                )
                        |> map (\_ -> allEmphasisedText)

                    , -- 
                      chompUntilNextClosing chompOpts
                    ]
            else
                succeed allEmphasisedText

        parseOneChar =
            succeed identity
                |= oneOf
                        [ map Just char
                        , map (\_ -> Nothing) end
                        ]

        preemptiveCheck =
            if emphasisChar == '_' then
                case originalCharBefore of
                    Just c ->
                        isUnicodeSpace c || isPunctuation c

                    Nothing ->
                        True
            else
                True
    in
    if preemptiveCheck then
        succeed identity
            |= some (specificChar emphasisChar)
            |> andThen
                    (\opening ->
                        let
                            closing =
                                String.fromArray (Array.pushFirst emphasisChar opening.rest)

                            times =
                                String.length closing
                        in
                        map
                            (\emphasisedText ->
                                emphasisedText
                                    |> parse
                                    |> Result.withDefault []
                                    |> Emphasis
                                            { times = times
                                            }
                            )
                            (chompUntilNextClosing
                                { checkOpening = True
                                , closing = closing
                                , emphasisedText = ""
                                }
                            )
                    )
    else
        problem "Emphasis pre-emptive check failed"


emphasisWithStarParser : Maybe Inline -> Parser Inline
emphasisWithStarParser =
    emphasisParser '*'


emphasisWithUnderscoreParser : Maybe Inline -> Parser Inline
emphasisWithUnderscoreParser =
    emphasisParser '_'


hardLineBreakParser : Parser Inline
hardLineBreakParser =
    succeed identity
        |. specificChar ' '
        |. specificChar ' '
        |. many (specificChar ' ')
        |. specificChar '\n'
        |> map (\_ -> HardLineBreak)


imageParser : Parser Inline
imageParser =
    succeed identity
        |. symbol "!["
        |= getChompedString (chompUntil "]")
        |. specificChar ']'
        |> andThen
                (\alt ->
                    -- TODO: Support image titles
                    succeed identity
                        |. specificChar '('
                        |= getChompedString (chompUntil ")")
                        |. specificChar ')'
                        |> map
                                (\url ->
                                    Image
                                        { alt = alt
                                        , url = url
                                        }
                                )
                )


inlineCodeParser : Array Inline -> Maybe Inline -> Parser (Step (Array Inline) (Array Inline))
inlineCodeParser inlineElements lastElement =
    succeed
        (\o s ->
            { opening = o ++ "`" ++ s
            , closing = s ++ o ++ "`"
            }
        )
        |. specificChar '`'
        |= getChompedString (chompWhile (\c -> c == '`'))
        |= oneOf
                [ getChompedString (symbol " ")
                , getChompedString (symbol "\n")
                , succeed ""
                ]
        |> andThen
                (\{ opening, closing } ->
                    let
                        chompUntilClosing close code =
                            succeed identity
                                |= getChompedString (chompUntilEndOr close)
                                |. symbol close
                                |> backtrackable
                                |> andThen (checkClosing close code)

                        checkClosing close code additionalCode =
                            let
                                allCode =
                                    code ++ additionalCode
                            in
                            succeed identity
                                |= oneOf
                                        [ map (\_ -> True) (specificChar '`')
                                        , succeed False
                                        ]
                                |> andThen
                                        (\bool ->
                                            if bool then
                                                -- problem "Closing did not match"
                                                chompUntilClosing close (allCode ++ closing ++ "`")
                                            else
                                                succeed allCode
                                        )

                        addToBlocks code =
                            let
                                finalCode =
                                    code
                                        |> (\c ->
                                                if code == "" && String.endsWith " " opening then
                                                    c ++ " "
                                                else
                                                    c
                                            )
                                        |> (\c ->
                                                if code == "" && String.startsWith " " closing then
                                                    c ++ " "
                                                else
                                                    c
                                            )
                                        |> String.replace "\n" " "
                            in
                            Loop (Array.pushLast (InlineCode finalCode) inlineElements)
                    in
                    oneOf
                        [ -- Either it's actual inline code:
                          -- (a) with some or no whitespace on both ends
                          map addToBlocks (chompUntilClosing closing "")

                        , -- (b) with some whitespace at the beginning, but not the end
                          map (\c -> addToBlocks (" " ++ c)) (chompUntilClosing (String.trimLeft closing) "")

                        , -- Or the opening is text
                          succeed (textLoop inlineElements lastElement opening)
                        ]
                )


linkParser : Parser Inline
linkParser =
    succeed identity
        |. specificChar '['
        |= getChompedString (chompUntil "]")
        |. specificChar ']'
        |> andThen
                (\text ->
                    if String.contains "`" text then
                        problem "Inline code has precedence"
                    else
                        -- TODO: Support link titles
                        succeed identity
                            |. specificChar '('
                            |= getChompedString (chompUntil ")")
                            |. specificChar ')'
                            |> andThen
                                    (\url ->
                                        if String.contains "`" url then
                                            problem "Inline code has precedence"
                                        else
                                            { text = text
                                            , url = url
                                            }
                                                |> Link
                                                |> succeed
                                    )
                )


{-| Parses one character at a time, so that it can try the other inline parsers
after each character. Concatenates `Text` automatically.
-}
textLoopParser : Array Inline -> Maybe Inline -> Parser (Step (Array Inline) (Array Inline))
textLoopParser inlineElements lastElement =
    succeed (textLoop inlineElements lastElement) |= getChompedString chompOne



-- ãŠ™ï¸


textLoop : Array Inline -> Maybe Inline -> String -> Step (Array Inline) (Array Inline)
textLoop inlineElements lastElement text =
    case text of
        "" ->
            Done inlineElements

        _ ->
            case lastElement of
                Just (Text previousText) ->
                    Loop (Array.pushLast (Text (previousText ++ text)) (Array.dropLast 1 inlineElements))

                _ ->
                    Loop (Array.pushLast (Text text) inlineElements)
