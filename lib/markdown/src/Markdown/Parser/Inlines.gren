module Markdown.Parser.Inlines exposing (..)

{-|-}

import Markdown.Inline exposing ( Inline(..) )
import Parser exposing (..)
import Parser.Extra exposing (..)



-- 🛠️


parse : String -> Result (Array DeadEnd) (Array Inline)
parse =
    Parser.run parser



-- TOP-LEVEL PARSER


parser : Parser (Array Inline)
parser =
    loop [] (parserLoop [])


parserLoop : Array (Parser Inline) -> Array Inline -> Parser (Step (Array Inline) (Array Inline))
parserLoop customInlineParsers inlineElements =
    let
        inline =
            map
                (\el ->
                    inlineElements
                        |> Array.pushLast el
                        |> Loop
                )

        lastElement =
            Array.last inlineElements
    in
    Parser.oneOf
        [ -- Check if we reached the end
          map (\_ -> Done inlineElements) end

        , --
          backtrackable (inlineCodeParser inlineElements lastElement)

        , --
          inline (backtrackable (emphasisWithUnderscoreParser lastElement))
        , inline (backtrackable (emphasisWithStarParser lastElement))
        , inline (backtrackable hardLineBreakParser)
        , inline (backtrackable imageParser)
        , inline (backtrackable linkParser)

        , --
          inline (backtrackable (oneOf customInlineParsers))

        , --
          textLoopParser inlineElements lastElement
        ]



-- INDIVIDUAL PARSERS


emphasisWithStarParser : Maybe Inline -> Parser Inline
emphasisWithStarParser lastElement =
    succeed identity
        |= some (specificChar '*')
        |> andThen
                (\opening ->
                    let
                        originalCharBefore =
                            case lastElement of
                                Just (Text t) ->
                                    Array.last (String.toArray t)

                                _ ->
                                    Nothing

                        closing =
                            "*" ++ String.fromArray opening.rest

                        times =
                            String.length closing

                        chompUntilNextClosing checkOpening emphasisedText skipOneClosing =
                            succeed identity
                                |= getChompedString (chompUntilEndOr closing)
                                |. symbol closing
                                |> andThen (check checkOpening emphasisedText skipOneClosing)

                        isViableOpening charBefore firstChar =
                            let
                                isPrecededByASpacePunctuationOrNothing =
                                    case charBefore of
                                        Just char ->
                                            isUnicodeSpace char || isPunctuation char

                                        _ ->
                                            True
                            in
                            if Maybe.map isUnicodeSpace firstChar == Just True then
                                False
                            else if Maybe.map isPunctuation firstChar == Just True && not isPrecededByASpacePunctuationOrNothing then
                                False
                            else
                                True

                        check checkOpening emphasisedText skipOneClosing additionalEmphasisedText =
                            let
                                allEmphasisedText =
                                    emphasisedText ++ additionalEmphasisedText

                                chars =
                                    String.toArray allEmphasisedText

                                firstChar =
                                    Array.first chars

                                lastChar =
                                    Array.last chars
                            in
                            if skipOneClosing then
                                chompUntilNextClosing False (allEmphasisedText ++ closing) False
                            else if checkOpening && not (isViableOpening originalCharBefore firstChar) then
                                problem "Illegal character, cannot emphasise"
                            else if Maybe.map isUnicodeSpace lastChar == Just True then
                                chompUntilNextClosing False (allEmphasisedText ++ closing) False
                            else if Maybe.map isPunctuation lastChar == Just True then
                                succeed identity
                                    |= oneOf
                                            [ map (\_ -> True) (lookAhead (chompIf (\c -> isUnicodeSpace c || isPunctuation c)))
                                            , map (\_ -> True) (lookAhead end)
                                            , succeed False
                                            ]
                                    |> andThen
                                            (\isViableClosing ->
                                                if isViableClosing then
                                                    succeed allEmphasisedText
                                                else
                                                    -- Is it another opening instead?
                                                    succeed identity
                                                        |= oneOf
                                                                [ map Just char
                                                                , map (\_ -> Nothing) end
                                                                ]
                                                        |> andThen
                                                                (\maybeFirstChar ->
                                                                    let
                                                                        first =
                                                                            case maybeFirstChar of
                                                                                Just char ->
                                                                                    Array.singleton char

                                                                                Nothing ->
                                                                                    Array.empty
                                                                    in
                                                                    chompUntilNextClosing False (allEmphasisedText ++ closing ++ String.fromArray first) (isViableOpening lastChar maybeFirstChar)
                                                                )
                                            )
                            else if String.contains "`" allEmphasisedText then
                                problem "Inline code has precedence"
                            else
                                succeed allEmphasisedText
                    in
                    map
                        (\emphasisedText ->
                            emphasisedText
                                |> parse
                                |> Result.withDefault []
                                |> Emphasis
                                        { times = times
                                        }
                        )
                        (chompUntilNextClosing True "" False)
                )


emphasisWithUnderscoreParser : Maybe Inline -> Parser Inline
emphasisWithUnderscoreParser lastElement =
    let
        isPrecededByASpacePunctuationOrNothing =
            case lastElement of
                Just (Text t) ->
                    case Array.last (String.toArray t) of
                        Just char ->
                            isUnicodeSpace char || isPunctuation char

                        Nothing ->
                            True

                _ ->
                    True
    in
    if isPrecededByASpacePunctuationOrNothing then
        succeed identity
            |= some (specificChar '_')
            |> andThen
                    (\opening ->
                        let
                            closing =
                                "_" ++ String.fromArray opening.rest

                            times =
                                String.length closing
                        in
                        succeed identity
                            |= getChompedString (chompUntilEndOr closing)
                            |. symbol closing
                            |> andThen
                                    (\emphasisedText ->
                                        let
                                            chars =
                                                String.toArray emphasisedText

                                            firstChar =
                                                Array.first chars

                                            lastChar =
                                                Array.last chars
                                        in
                                        if Maybe.map isUnicodeSpace firstChar == Just True then
                                            problem "Illegal character, cannot emphasise"
                                        else if Maybe.map isUnicodeSpace lastChar == Just True then
                                            problem "Illegal character, cannot emphasise"
                                        else if Maybe.map isPunctuation lastChar == Just True then
                                            succeed identity
                                                |. oneOf
                                                        [ chompIf (\c -> isUnicodeSpace c || isPunctuation c)
                                                        , end
                                                        ]
                                                |> map (\_ -> emphasisedText)
                                        else if String.contains "`" emphasisedText then
                                            problem "Inline code has precedence"
                                        else
                                            succeed emphasisedText
                                    )
                            |> map
                                    (\emphasisedText ->
                                        emphasisedText
                                            |> parse
                                            |> Result.withDefault []
                                            |> Emphasis
                                                    { times = times
                                                    }
                                    )
                    )
    else
        problem "Cannot emphasise if not preceded by a space"


hardLineBreakParser : Parser Inline
hardLineBreakParser =
    succeed identity
        |. specificChar ' '
        |. specificChar ' '
        |. many (specificChar ' ')
        |. specificChar '\n'
        |> map (\_ -> HardLineBreak)


imageParser : Parser Inline
imageParser =
    succeed identity
        |. symbol "!["
        |= getChompedString (chompUntil "]")
        |. specificChar ']'
        |> andThen
                (\alt ->
                    -- TODO: Support image titles
                    succeed identity
                        |. specificChar '('
                        |= getChompedString (chompUntil ")")
                        |. specificChar ')'
                        |> map
                                (\url ->
                                    Image
                                        { alt = alt
                                        , url = url
                                        }
                                )
                )


inlineCodeParser : Array Inline -> Maybe Inline -> Parser (Step (Array Inline) (Array Inline))
inlineCodeParser inlineElements lastElement =
    succeed
        (\o s ->
            { opening = o ++ "`" ++ s
            , closing = s ++ o ++ "`"
            }
        )
        |. specificChar '`'
        |= getChompedString (chompWhile (\c -> c == '`'))
        |= oneOf
                [ getChompedString (symbol " ")
                , getChompedString (symbol "\n")
                , succeed ""
                ]
        |> andThen
                (\{ opening, closing } ->
                    let
                        chompUntilClosing close code =
                            succeed identity
                                |= getChompedString (chompUntilEndOr close)
                                |. symbol close
                                |> backtrackable
                                |> andThen (checkClosing close code)

                        checkClosing close code additionalCode =
                            let
                                allCode =
                                    code ++ additionalCode
                            in
                            succeed identity
                                |= oneOf
                                        [ map (\_ -> True) (specificChar '`')
                                        , succeed False
                                        ]
                                |> andThen
                                        (\bool ->
                                            if bool then
                                                -- problem "Closing did not match"
                                                chompUntilClosing close (allCode ++ closing ++ "`")
                                            else
                                                succeed allCode
                                        )

                        addToBlocks code =
                            let
                                finalCode =
                                    code
                                        |> (\c ->
                                                if code == "" && String.endsWith " " opening then
                                                    c ++ " "
                                                else
                                                    c
                                            )
                                        |> (\c ->
                                                if code == "" && String.startsWith " " closing then
                                                    c ++ " "
                                                else
                                                    c
                                            )
                                        |> String.replace "\n" " "
                            in
                            Loop (Array.pushLast (InlineCode finalCode) inlineElements)
                    in
                    oneOf
                        [ -- Either it's actual inline code:
                          -- (a) with some or no whitespace on both ends
                          map addToBlocks (chompUntilClosing closing "")

                        , -- (b) with some whitespace at the beginning, but not the end
                          map (\c -> addToBlocks (" " ++ c)) (chompUntilClosing (String.trimLeft closing) "")

                        , -- Or the opening is text
                          succeed (textLoop inlineElements lastElement opening)
                        ]
                )


linkParser : Parser Inline
linkParser =
    succeed identity
        |. specificChar '['
        |= getChompedString (chompUntil "]")
        |. specificChar ']'
        |> andThen
                (\text ->
                    if String.contains "`" text then
                        problem "Inline code has precedence"
                    else
                        -- TODO: Support link titles
                        succeed identity
                            |. specificChar '('
                            |= getChompedString (chompUntil ")")
                            |. specificChar ')'
                            |> andThen
                                    (\url ->
                                        if String.contains "`" url then
                                            problem "Inline code has precedence"
                                        else
                                            { text = text
                                            , url = url
                                            }
                                                |> Link
                                                |> succeed
                                    )
                )


{-| Parses one character at a time, so that it can try the other inline parsers
after each character. Concatenates `Text` automatically.
-}
textLoopParser : Array Inline -> Maybe Inline -> Parser (Step (Array Inline) (Array Inline))
textLoopParser inlineElements lastElement =
    succeed (textLoop inlineElements lastElement) |= getChompedString chompOne



-- ㊙️


textLoop : Array Inline -> Maybe Inline -> String -> Step (Array Inline) (Array Inline)
textLoop inlineElements lastElement text =
    case text of
        "" ->
            Done inlineElements

        _ ->
            case lastElement of
                Just (Text previousText) ->
                    Loop (Array.pushLast (Text (previousText ++ text)) (Array.dropLast 1 inlineElements))

                _ ->
                    Loop (Array.pushLast (Text text) inlineElements)
