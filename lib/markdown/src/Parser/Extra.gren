module Parser.Extra exposing (..)

{-|-}

import Parser exposing (..)



-- 🏔️


isLineEnding c =
    c == '\n' || c == '\r'


isPunctuation c =
    let
        code =
            Char.toCode c
    in
    (code >= 33 && code <= 47) || (code >= 58 && code <= 64) || (code >= 91 && code <= 96) || (code >= 123 && code <= 126)


isSpace c =
    c == ' '


isTab c =
    c == '\t'


isUnicodeSpace c =
    let
        code =
            Char.toCode c
    in
    isSpace c || isLineEnding c || isTab c || code == 12 || code == 160 || code == 5760 || (code >= 8192 && code <= 8202) || code == 8239 || code == 8287 || code == 12288



-- 🛠️


char : Parser Char
char =
    chompOne
        |> getChompedString
        |> map (String.toArray >> Array.first >> Maybe.withDefault ' ')


chompIfChar : Char -> Parser {}
chompIfChar c =
    chompIf (\a -> a == c)


chompOne : Parser {}
chompOne =
    chompIf (always True)


chompOneOrMore : (Char -> Bool) -> Parser {}
chompOneOrMore predicate =
    chompIf predicate |. chompWhile predicate


{-| Create a parser that backtracks on success.
-}
lookAhead : Parser a -> Parser {}
lookAhead parser =
    oneOf
        [ oneOf
            [ parser
                |> backtrackable
                |> andThen (\a -> commit {})
                |> andThen (\_ -> problem "")
            , succeed
                (parser
                    |> backtrackable
                    |> map (\_ -> {})
                )
            ]
            |> backtrackable
        , succeed (succeed {})
        ]
        |> andThen identity


many : Parser a -> Parser (Array a)
many p =
    loop [] (manyHelp p)


notMoreThanXSpaces : Int -> Parser (Array Char)
notMoreThanXSpaces n =
    succeed identity
        |= many (specificChar ' ')
        |> andThen
                (\spaces ->
                    if Array.length spaces > n then
                        problem ("Encountered more than " ++ String.fromInt n ++ " spaces")
                    else
                        succeed spaces
                )


some :
    Parser a
    -> Parser
        { match : a
        , rest : Array a
        }
some p =
    succeed
        (\a b ->
            { match = a
            , rest = b
            }
        )
        |= p
        |= many p


specificChar : Char -> Parser Char
specificChar c =
    map (\_ -> c) (chompIfChar c)



-- ㊙️


manyHelp : Parser a -> Array a -> Parser (Step (Array a) (Array a))
manyHelp p vs =
    oneOf
        [ succeed
            (\v ->
                vs
                    |> Array.pushLast v
                    |> Loop
            )
            |= p
        , succeed (Done vs)
        ]
