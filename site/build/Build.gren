module Build exposing ( main )

import Bytes exposing ( Bytes )
import Bytes.Decode
import Bytes.Encode
import Dict
import Essays
import FileSystem
import Json.Decode as Json
import Json.Encode
import Layouts.Base
import Layouts.Markdown
import Markdown
import Markdown.Block as Markdown exposing (..)
import Markdown.Inline as Markdown exposing (..)
import Markdown.Transmutationist
import Pages exposing ( Page, TableOfContents )
import Shikensu
import Shikensu.Bundle as Shikensu
import Shikensu.Contrib as Shikensu
import Shikensu.Definition as Shikensu
import Shikensu.Error exposing ( Error(..) )
import Shikensu.Focus as Shikensu exposing ( Focus(..) )
import Shikensu.Path as Path
import Stream
import Task exposing ( Task )
import Time
import Transmutable.Html exposing ( Html )
import Views.Pages



-- 🏔️


dist =
    [ ".."
    , "dist"
    ]
        |> Path.directory
        |> Relative



-- 🚀


main : Shikensu.Program
main =
    Shikensu.perform
        { onSuccess = \env _ -> Stream.sendLine env.stdout "🧪 Sequence completed"
        , onError = \env err -> Stream.sendLine env.stderr ("🚨 " ++ Shikensu.Error.toString err)
        }
        sequence


sequence : FileSystem.Permission -> Task Error {}
sequence fsPermission =
    Task.andThen
        (\time ->
            [ processMarkdown "essays" essayHandler Pages.essay fsPermission time
            , processMarkdown "notes" notesHandler Pages.note fsPermission time
            ]
                |> Task.sequence
                |> Task.andThen
                        (\results ->
                            case results of
                                [ essays, notes ] ->
                                    Task.succeed
                                        { essayTableOfContents = essays
                                        , notesTableOfContents = notes
                                        }

                                _ ->
                                    Task.fail (ErrorMessage "Faulty markdown processing result")
                        )
                |> Task.andThen (writePagesToDisk fsPermission time)
                |> Task.map (\_ -> {})
        )
        Time.now


processMarkdown :
    String
    -> (Time.Posix -> Array Shikensu.Definition -> Array Shikensu.Definition)
    -> ({ baseName : String
        , title : String
        }
        -> Page
       )
    -> FileSystem.Permission
    -> Time.Posix
    -> Task Error TableOfContents
processMarkdown dir handler pageCreator fsPermission time =
    [ ".."
    , dir
    ]
        |> Path.directory
        |> Relative
        |> Shikensu.list fsPermission
        |> Task.map (Shikensu.withExtension "md")
        |> Task.andThen Shikensu.read
        |> Task.map
                (\bundle ->
                    bundle
                        |> Shikensu.enclose dir
                        |> Shikensu.renameExtension "md" "html"
                        |> Shikensu.mapCompendium (handler time)
                        |> Shikensu.permalink "index"
                )
        |> Task.andThen (Shikensu.write dist)
        |> Task.map
                (\bundle ->
                    -- Build a table of contents
                    Array.map
                        (\def ->
                            { page =
                                pageCreator
                                    { baseName = Maybe.withDefault def.baseName (Array.last (Path.unwrap def.directoryPath))
                                    , title = meta "title" Json.string def.baseName def
                                    }
                            , archived = meta "archived" Json.bool False def
                            }
                        )
                        bundle.compendium
                )


writePagesToDisk :
    FileSystem.Permission
    -> Time.Posix
    -> { essayTableOfContents : TableOfContents
       , notesTableOfContents : TableOfContents
       }
    -> Task Error TableOfContents
writePagesToDisk fsPermission time toc =
    let
        makeDefinition mod =
            { baseName = "index"
            , content = Just (htmlBytes (Layouts.Base.layout mod time (Views.Pages.view toc mod)))
            , directoryPath = Path.directory mod.route
            , extensionName = Just "html"
            , metadata = Dict.empty
            }
    in
    Pages.allPages
        |> Array.map makeDefinition
        |> Shikensu.bundle fsPermission
        |> Task.andThen (Shikensu.write dist)
        |> Task.map (\_ -> [])



-- 🛠️ BYTES


bytesToString : Bytes -> Maybe String
bytesToString bytes =
    bytes
        |> Bytes.width
        |> Bytes.Decode.string
        |> (\decoder -> Bytes.Decode.decode decoder bytes)


htmlBytes : Array (Html msg) -> Bytes
htmlBytes =
    Transmutable.Html.arrayToString >> Bytes.Encode.string >> Bytes.Encode.encode



-- 🛠️ MARKDOWN


essayHandler : Time.Posix -> Array Shikensu.Definition -> Array Shikensu.Definition
essayHandler time compendium =
    compendium
        |> Array.filterMap
                (\def ->
                    def.content
                        |> Maybe.andThen bytesToString
                        |> Maybe.andThen
                                (\markdownString ->
                                    markdownString
                                        |> Markdown.parse
                                                { frontmatter = Just (Markdown.jsonFrontmatter Essays.frontmatterDecoder)
                                                }
                                        |> (\{ blocks, metadata } ->
                                                Maybe.map
                                                    (\m ->
                                                        { blocks = blocks
                                                        , markdown = markdownString
                                                        , metadata = m
                                                        }
                                                    )
                                                    metadata
                                            )
                                )
                        |> Maybe.andThen
                                (\record ->
                                    -- Only use published essays
                                    if record.metadata.published then
                                        Just record
                                    else
                                        Nothing
                                )
                        |> Maybe.map
                                (\{ blocks, markdown, metadata } ->
                                    let
                                        page =
                                            Pages.essay
                                                { baseName = def.baseName
                                                , title = metadata.title
                                                }

                                        renderedMarkdown =
                                            blocks
                                                |> Array.map markdownToHtml
                                                |> Layouts.Markdown.layout page "decoration-accent-essays"
                                                |> Layouts.Base.layout page time
                                                |> htmlBytes
                                    in
                                    { def
                                        | content = Just renderedMarkdown
                                        , metadata =
                                            Dict.fromArray
                                                [ { key = "archived"
                                                  , value = Json.Encode.bool metadata.archived
                                                  }
                                                , { key = "markdown"
                                                  , value = Json.Encode.string markdown
                                                  }
                                                , { key = "published"
                                                  , value = Json.Encode.bool metadata.published
                                                  }
                                                , { key = "publishedOn"
                                                  , value = Json.Encode.string metadata.publishedOn
                                                  }
                                                , { key = "title"
                                                  , value = Json.Encode.string metadata.title
                                                  }
                                                ]
                                    }
                                )
                )
        |> Array.sortBy (\def -> meta "title" Json.string def.baseName def)


notesHandler : Time.Posix -> Array Shikensu.Definition -> Array Shikensu.Definition
notesHandler time compendium =
    compendium
        |> Array.filterMap
                (\def ->
                    def.content
                        |> Maybe.andThen bytesToString
                        |> Maybe.map
                                (\markdownString ->
                                    markdownString
                                        |> Markdown.parse
                                                { frontmatter = Nothing
                                                }
                                        |> (\{ blocks } ->
                                                { blocks = postProcessNotesMarkdown blocks
                                                , markdown = markdownString
                                                }
                                            )
                                )
                        |> Maybe.map
                                (\{ blocks, markdown } ->
                                    let
                                        page =
                                            Pages.note
                                                { baseName = def.baseName
                                                , title = def.baseName
                                                }

                                        renderedMarkdown =
                                            blocks
                                                |> Array.map markdownToHtml
                                                |> Layouts.Markdown.layout page "decoration-accent-notes"
                                                |> Layouts.Base.layout page time
                                                |> htmlBytes
                                    in
                                    { def
                                        | content = Just renderedMarkdown
                                        , metadata =
                                            Dict.fromArray
                                                [ { key = "markdown"
                                                  , value = Json.Encode.string markdown
                                                  }
                                                , { key = "title"
                                                  , value = Json.Encode.string def.baseName
                                                  }
                                                ]
                                    }
                                )
                )
        |> Array.sortBy (\def -> meta "title" Json.string def.baseName def)


postProcessNotesMarkdown : Array Markdown.Block -> Array Markdown.Block
postProcessNotesMarkdown =
    let
        inlineHandler inline =
            case inline of
                Image { alt, url } ->
                    Image
                        { alt = alt
                        , url =
                            if String.startsWith "Embeds/" url then
                                "../" ++ url
                            else
                                url
                        }

                i ->
                    i
    in
    Array.map
        (\block ->
            case block of
                BlockQuote blocks ->
                    BlockQuote (postProcessNotesMarkdown blocks)

                Heading opts inlines ->
                    Heading opts (Array.map inlineHandler inlines)

                HtmlBlockNode opts blocks ->
                    HtmlBlockNode opts (postProcessNotesMarkdown blocks)

                Inline inline ->
                    Inline (inlineHandler inline)

                OrderedLooseList opts itemsWithBlocks ->
                    OrderedLooseList opts (Array.map postProcessNotesMarkdown itemsWithBlocks)

                OrderedTightList opts itemsWithInlines ->
                    OrderedTightList opts (Array.map (Array.map inlineHandler) itemsWithInlines)

                Paragraph inlines ->
                    Paragraph (Array.map inlineHandler inlines)

                UnorderedLooseList itemsWithBlocks ->
                    UnorderedLooseList (Array.map postProcessNotesMarkdown itemsWithBlocks)

                UnorderedTightList itemsWithInlines ->
                    UnorderedTightList (Array.map (Array.map inlineHandler) itemsWithInlines)

                b ->
                    b
        )


createMarkdownJsonRepo : String -> Array Shikensu.Definition -> Array Shikensu.Definition
createMarkdownJsonRepo name compendium =
    compendium
        |> Array.filterMap
                (\def ->
                    Maybe.map2
                        (\m baseName ->
                            Json.Encode.object
                                [ { key = "baseName"
                                  , value = Json.Encode.string baseName
                                  }
                                , { key = "markdown"
                                  , value = m
                                  }
                                ]
                        )
                        (Dict.get "markdown" def.metadata)
                        (Array.last (Path.unwrap def.directoryPath))
                )
        |> Json.Encode.array identity
        |> Json.Encode.encode 0
        |> Bytes.Encode.string
        |> Bytes.Encode.encode
        |> (\json ->
                { baseName = name
                , content = Just json
                , directoryPath = Path.directory []
                , extensionName = Just "json"
                , metadata = Dict.empty
                }
            )
        |> (\def -> Array.pushLast def compendium)



-- 🛠️


meta key decoder default definition =
    definition.metadata
        |> Dict.get key
        |> Maybe.andThen (Json.decodeValue decoder >> Result.toMaybe)
        |> Maybe.withDefault default


markdownToHtml =
    Markdown.Transmutationist.toHtmlWithOptions
        { imageLoadingStrategy = Markdown.Transmutationist.Lazy
        }
