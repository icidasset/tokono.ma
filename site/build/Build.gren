module Build exposing ( main )

import Bytes exposing ( Bytes )
import Bytes.Decode
import Bytes.Encode
import Dict
import FileSystem
import Json.Decode as Json
import Json.Encode
import Layouts.Base
import Layouts.Markdown
import Markdown
import Pages
import Shikensu
import Shikensu.Bundle as Shikensu
import Shikensu.Contrib as Shikensu
import Shikensu.Definition as Shikensu
import Shikensu.Error exposing ( Error )
import Shikensu.Focus as Shikensu exposing ( Focus(..) )
import Shikensu.Path as Path
import Stream
import Task exposing ( Task )
import Time
import Transmutable.Html exposing ( Html )
import Views.Pages



-- 🚀


main : Shikensu.Program
main =
    Shikensu.perform
        { onSuccess = \env _ -> Stream.sendLine env.stdout "🧪 Sequence completed"
        , onError = \env err -> Stream.sendLine env.stderr ("🚨 " ++ Shikensu.Error.toString err)
        }
        sequence


sequence : FileSystem.Permission -> Task Error {}
sequence fsPermission =
    Time.now
        |> Task.andThen
                (\time ->
                    Task.sequence
                        [ writePagesToDisk fsPermission time
                        , processEssays fsPermission time
                        ]
                )
        |> Task.map (\_ -> {})


processEssays : FileSystem.Permission -> Time.Posix -> Task Error {}
processEssays fsPermission time =
    [ ".."
    , "essays"
    ]
        |> Path.directory
        |> Relative
        |> Shikensu.list fsPermission
        |> Task.map (Shikensu.withExtension "md")
        |> Task.andThen Shikensu.read
        |> Task.map
                (\bundle ->
                    bundle
                        |> Shikensu.renameExtension "md" "html"
                        |> Shikensu.permalink "index"
                        |> Shikensu.renderContent (renderMarkdown time)
                        |> Shikensu.mapCompendium
                                (\compendium ->
                                    let
                                        published =
                                            onlyPublished compendium
                                    in
                                    bundle.compendium
                                        |> Array.filter (\def -> Array.member def.baseName published.baseNames)
                                        |> createMarkdownJsonRepo "essays"
                                        |> (\def -> Array.pushLast def published.compendium)
                                )
                )
        |> Task.andThen
                ([ ".."
                 , "dist"
                 , "essays"
                 ]
                    |> Path.directory
                    |> Relative
                    |> Shikensu.write
                )
        |> Task.map (\_ -> {})


writePagesToDisk : FileSystem.Permission -> Time.Posix -> Task Error {}
writePagesToDisk fsPermission time =
    fsPermission
        |> Shikensu.currentWorkingDirectory
        -- Destination directory: `../dist/`
        |> Task.map
                (\path ->
                    [ ".."
                    , "dist"
                    ]
                        |> Path.directory
                        |> Path.combine path
                )
        -- Write each page to disk
        |> Task.andThen
                (\destinationDir ->
                    let
                        page mod html =
                            { baseName = "index"
                            , content = Just (htmlBytes (Layouts.Base.layout mod time html))
                            , directoryPath = Path.directory mod.route
                            , extensionName = Just "html"
                            , metadata = Dict.empty
                            }
                    in
                    Pages.allPages
                        |> Array.map (\p -> page p (Views.Pages.view p))
                        |> Array.map (Shikensu.writeDefinition fsPermission destinationDir)
                        |> Task.sequence
                )
        --
        |> Task.map (\_ -> {})



-- 🛠️


bytesToString : Bytes -> Maybe String
bytesToString bytes =
    bytes
        |> Bytes.width
        |> Bytes.Decode.string
        |> (\decoder -> Bytes.Decode.decode decoder bytes)


createMarkdownJsonRepo : String -> Array Shikensu.Definition -> Shikensu.Definition
createMarkdownJsonRepo name compendium =
    compendium
        |> Array.foldl
                (\def acc ->
                    case Maybe.andThen bytesToString def.content of
                        Just markdownString ->
                            Array.pushLast
                                { key = def.baseName
                                , value = Json.Encode.string markdownString
                                }
                                acc

                        _ ->
                            acc
                )
                []
        |> Json.Encode.object
        |> Json.Encode.encode 0
        |> Bytes.Encode.string
        |> Bytes.Encode.encode
        |> (\json ->
                { baseName = name
                , content = Just json
                , directoryPath = Path.directory []
                , extensionName = Just "json"
                , metadata = Dict.empty
                }
            )


frontmatterDecoder =
    Json.map3
        (\published publishedOn title ->
            { published = published
            , publishedOn = publishedOn
            , title = title
            }
        )
        (Json.field "published" Json.bool)
        (Json.field "published_on" Json.string)
        (Json.field "title" Json.string)


htmlBytes : Html msg -> Bytes
htmlBytes =
    Transmutable.Html.toString >> Bytes.Encode.string >> Bytes.Encode.encode


onlyPublished =
    Array.foldl
        (\def acc ->
            case def.content of
                Just _ ->
                    { baseNames =
                        def.directoryPath
                            |> Path.unwrap
                            |> Array.last
                            |> Maybe.withDefault def.baseName
                            |> (\a -> Array.pushLast a acc.baseNames)
                    , compendium = Array.pushLast def acc.compendium
                    }

                Nothing ->
                    acc
        )
        { baseNames = []
        , compendium = []
        }


renderMarkdown time def =
    def.content
        |> Maybe.andThen bytesToString
        |> Maybe.andThen
                (\markdownString ->
                    markdownString
                        |> Markdown.parse
                                { frontmatter = Just (Markdown.jsonFrontmatter frontmatterDecoder)
                                }
                        |> (\{ blocks, metadata } ->
                                case metadata of
                                    Just { title, published } ->
                                        if published then
                                            let
                                                page =
                                                    Pages.essay
                                                        { baseName = def.baseName
                                                        , title = title
                                                        }
                                            in
                                            blocks
                                                |> Array.map Markdown.toHtml
                                                |> Layouts.Markdown.layout page
                                                |> Layouts.Base.layout page time
                                                |> Just
                                        else
                                            Nothing

                                    Nothing ->
                                        Nothing
                            )
                )
        |> Maybe.map htmlBytes
