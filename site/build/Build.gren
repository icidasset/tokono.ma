module Build exposing ( main )

import Bytes exposing ( Bytes )
import Bytes.Decode
import Bytes.Encode
import Dict
import FileSystem
import Json.Decode as Json
import Json.Encode
import Layouts.Base
import Layouts.Markdown
import Markdown
import Pages
import Shikensu
import Shikensu.Bundle as Shikensu
import Shikensu.Contrib as Shikensu
import Shikensu.Definition as Shikensu
import Shikensu.Error exposing ( Error )
import Shikensu.Focus as Shikensu exposing ( Focus(..) )
import Shikensu.Path as Path
import Stream
import Task exposing ( Task )
import Time
import Transmutable.Html exposing ( Html )
import Views.Pages



-- 🚀


main : Shikensu.Program
main =
    Shikensu.perform
        { onSuccess = \env _ -> Stream.sendLine env.stdout "🧪 Sequence completed"
        , onError = \env err -> Stream.sendLine env.stderr ("🚨 " ++ Shikensu.Error.toString err)
        }
        sequence


sequence : FileSystem.Permission -> Task Error {}
sequence fsPermission =
    Time.now
        |> Task.andThen
                (\time ->
                    Task.sequence
                        [ writePagesToDisk fsPermission time
                        , processEssays fsPermission time
                        ]
                )
        |> Task.map (\_ -> {})


processEssays : FileSystem.Permission -> Time.Posix -> Task Error {}
processEssays fsPermission time =
    [ ".."
    , "essays"
    ]
        |> Path.directory
        |> Relative
        |> Shikensu.list fsPermission
        |> Task.map (Shikensu.withExtension "md")
        |> Task.andThen Shikensu.read
        |> Task.map
                (\bundle ->
                    bundle
                        |> Shikensu.renameExtension "md" "html"
                        |> Shikensu.permalink "index"
                        |> Shikensu.mapCompendium (consumeAndRenderMarkdown time)
                        |> Shikensu.mapCompendium (createMarkdownJsonRepo "essays")
                )
        |> Task.andThen
                ([ ".."
                 , "dist"
                 , "essays"
                 ]
                    |> Path.directory
                    |> Relative
                    |> Shikensu.write
                )
        |> Task.map (\_ -> {})


writePagesToDisk : FileSystem.Permission -> Time.Posix -> Task Error {}
writePagesToDisk fsPermission time =
    fsPermission
        |> Shikensu.currentWorkingDirectory
        -- Destination directory: `../dist/`
        |> Task.map
                (\path ->
                    [ ".."
                    , "dist"
                    ]
                        |> Path.directory
                        |> Path.combine path
                )
        -- Write each page to disk
        |> Task.andThen
                (\destinationDir ->
                    let
                        page mod html =
                            { baseName = "index"
                            , content = Just (htmlBytes (Layouts.Base.layout mod time html))
                            , directoryPath = Path.directory mod.route
                            , extensionName = Just "html"
                            , metadata = Dict.empty
                            }
                    in
                    Pages.allPages
                        |> Array.map (\p -> page p (Views.Pages.view p))
                        |> Array.map (Shikensu.writeDefinition fsPermission destinationDir)
                        |> Task.sequence
                )
        -- 
        |> Task.map (\_ -> {})



-- 🛠️ BYTES


bytesToString : Bytes -> Maybe String
bytesToString bytes =
    bytes
        |> Bytes.width
        |> Bytes.Decode.string
        |> (\decoder -> Bytes.Decode.decode decoder bytes)


htmlBytes : Html msg -> Bytes
htmlBytes =
    Transmutable.Html.toString >> Bytes.Encode.string >> Bytes.Encode.encode



-- 🛠️ MARKDOWN


consumeAndRenderMarkdown : Time.Posix -> Array Shikensu.Definition -> Array Shikensu.Definition
consumeAndRenderMarkdown time =
    Array.filterMap
        (\def ->
            def.content
                |> Maybe.andThen bytesToString
                |> Maybe.andThen
                        (\markdownString ->
                            markdownString
                                |> Markdown.parse
                                        { frontmatter = Just (Markdown.jsonFrontmatter frontmatterDecoder)
                                        }
                                |> (\{ blocks, metadata } ->
                                        Maybe.map
                                            (\m ->
                                                { blocks = blocks
                                                , markdown = markdownString
                                                , metadata = m
                                                }
                                            )
                                            metadata
                                    )
                        )
                |> Maybe.andThen
                        (\record ->
                            -- Only use published essays
                            if record.metadata.published then
                                Just record
                            else
                                Nothing
                        )
                |> Maybe.map
                        (\{ blocks, markdown, metadata } ->
                            let
                                page =
                                    Pages.essay
                                        { baseName = def.baseName
                                        , title = metadata.title
                                        }

                                renderedMarkdown =
                                    blocks
                                        |> Array.map Markdown.toHtml
                                        |> Layouts.Markdown.layout page
                                        |> Layouts.Base.layout page time
                                        |> htmlBytes
                            in
                            { def
                                | content = Just renderedMarkdown
                                , metadata =
                                    Dict.fromArray
                                        [ { key = "archived"
                                          , value = Json.Encode.bool metadata.archived
                                          }
                                        , { key = "markdown"
                                          , value = Json.Encode.string markdown
                                          }
                                        , { key = "published"
                                          , value = Json.Encode.bool metadata.published
                                          }
                                        , { key = "publishedOn"
                                          , value = Json.Encode.string metadata.publishedOn
                                          }
                                        , { key = "title"
                                          , value = Json.Encode.string metadata.title
                                          }
                                        ]
                            }
                        )
        )


createMarkdownJsonRepo : String -> Array Shikensu.Definition -> Array Shikensu.Definition
createMarkdownJsonRepo name compendium =
    compendium
        |> Array.filterMap
                (\def ->
                    Maybe.map2
                        (\m baseName ->
                            { key = baseName
                            , value = m
                            }
                        )
                        (Dict.get "markdown" def.metadata)
                        (Array.last (Path.unwrap def.directoryPath))
                )
        |> Json.Encode.object
        |> Json.Encode.encode 0
        |> Bytes.Encode.string
        |> Bytes.Encode.encode
        |> (\json ->
                { baseName = name
                , content = Just json
                , directoryPath = Path.directory []
                , extensionName = Just "json"
                , metadata = Dict.empty
                }
            )
        |> (\def -> Array.pushLast def compendium)


frontmatterDecoder =
    Json.map4
        (\maybeArchived published publishedOn title ->
            { archived = Maybe.withDefault False maybeArchived
            , published = published
            , publishedOn = publishedOn
            , title = title
            }
        )
        (Json.maybe (Json.field "archived" Json.bool))
        (Json.field "published" Json.bool)
        (Json.field "published_on" Json.string)
        (Json.field "title" Json.string)
