module Common.Html.Keyed exposing ( node, ol, ul )

{-| A keyed node helps optimize cases where children are getting added, moved,
removed, etc. Common examples include:

  - The user can delete items from a list.
  - The user can create new items in a list.
  - You can sort a list based on name or date or whatever.

When you use a keyed node, every child is paired with a string identifier. This
makes it possible for the underlying diffing algorithm to reuse nodes more
efficiently.

# Keyed Nodes
@docs node

# Commonly Keyed Nodes
@docs ol, ul
-}

import Common.Html exposing ( Attribute, Html )
import Common.Html.Interior as Interior


{-| Works just like `Html.node`, but you add a unique identifier to each child
node. You want this when you have a list of nodes that is changing: adding
nodes, removing nodes, etc. In these cases, the unique identifiers help make
the DOM modifications more efficient.
-}
node :
    String
    -> Array (Attribute msg)
    -> Array
        { key : String
        , node : Html msg
        }
    -> Html msg
node tagName descendants =
    descendants
        |> Array.map
                (\{ key, node } ->
                    case node of
                        Node props tagName attrs descendants ->
                            NodeWithKey { props | key = Just key } tagName attrs descendants

                        TextNode t ->
                            TextNode t
                )
        |> Interior.Node tagName


{-|-}
ol :
    Array (Attribute msg)
    -> Array
        { key : String
        , node : Html msg
        }
    -> Html msg
ol =
    node "ol"


{-|-}
ul :
    Array (Attribute msg)
    -> Array
        { key : String
        , node : Html msg
        }
    -> Html msg
ul =
    node "ul"
